# How does this program work
## About the suggested fature
Further Considerations:
1. Could consider what to do if a process dies and would prefer to resume at the current
   processing position on restart.
   1. Rabbit mq will secure save and store the content of the queue in local file, and restore it when it is runned again
2. Could consider how to persist data that has not been normalized. 
   1. The data not been normalized is securely store in the rabbit mq queue, and will not loss
3. Could consider various methods of interprocess communication between the raw process
   and the normalizer process (e.g. shared memory, pipes, and websocket).
   1. The inter process communication is most automatically handle by rabbitmq, but I do do several things to make sure it is squential
      1. 1: There is an ACK and NACK between producer and consumer, it will guratee the transcation between producer and consumer will definitely happen
      1. Even if one of them producer or consumer failed, rabbitmq will automatically restore entire transaction by redo the job again
```agsl
           // Producer
           Channel channel = connection.createChannel()) {

            // Declare a durable exchange
            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, true);

            // Declare a durable queue
            channel.queueDeclare(QUEUE_NAME, true, false, false, null);

            // Bind the queue to the exchange
            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "");

            AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
                    .deliveryMode(2) // Make message persistent
                    .build();

            data = data + "," + this.counter.getAndIncrement().toString();

            channel.basicPublish(EXCHANGE_NAME, "", properties, data.getBytes(StandardCharsets.UTF_8));
            System.out.println("Produced: " + data);
            
            //------------------------------------
            // Consumer

            // Set QoS to 1 to ensure sequential processing
            channel.basicQos(1);

            System.out.println(" [*] Waiting for messages. To exit press CTRL+C");

            DeliverCallback deliverCallback = (consumerTag, delivery) -> {
                String message = new String(delivery.getBody(), StandardCharsets.UTF_8);
                try {
                    System.out.println(" [x] Received '" + message + "', start to persistence");
                    this.dataPersistance(message);
                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
                } catch (Exception e) {
                    System.err.println("Error processing message: " + e.getMessage());
                    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);
                }
            };

            channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -> { });
```
4. Could consider optimizing the serialization format if time permits.
   1. I optimize the serialization format by storing it in a local sql database, leveraging the sqllite3
      1. It can guarantee the ASIC property, and it is recoverable 
      1. It is light weight, and more readable
      2. It is compatible with most of companeis requirement
         3. I do think this is a bad idea though
## How does it work in simple words
* Bsically, a bunch of producer is reading from the websocket, and a bunch of consumer read the contexts that are generated by the producer.
* The consumers read the content sequentially, after the consumer finish consuming, it says ACK, anything wrong it says NACK
* After the producer hear the respond, the transcation is done, and it will keep listening.
* Ideally, one producer should face with one consumer, other wise it make 0 sense since the API of website is not very fast.

## TechStack explained
* rabbitmq
  * A high performance 